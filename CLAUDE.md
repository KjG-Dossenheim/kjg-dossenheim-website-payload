# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is the KjG Dossenheim website, a Next.js application powered by Payload CMS (v3.x). It serves as a content management system and website for the KjG Dossenheim community, a Catholic youth organization in Dossenheim, Germany.

**Key Technologies:**
- Next.js 15+ with App Router
- Payload CMS 3.x (headless CMS)
- MongoDB (via Mongoose adapter)
- TypeScript
- Tailwind CSS 4.x
- Lexical Rich Text Editor
- React 19
- S3-compatible storage (Cloudflare R2)

## Development Commands

**Start development server:**
```bash
pnpm dev
```

**Build for production:**
```bash
pnpm build
```
Note: `postbuild` script automatically runs `next-sitemap` after the build.

**Start production server:**
```bash
pnpm start
```

**Development in production mode:**
```bash
pnpm dev:prod
```
This removes `.next`, builds, and starts the production server.

**Safe development restart:**
```bash
pnpm devsafe
```
Removes `.next` directory and starts fresh dev server.

**Type generation:**
```bash
pnpm generate:types
```
Generates TypeScript types from Payload collections/globals into `src/payload-types.ts`.

**Import map generation:**
```bash
pnpm generate:importmap
```

**Linting:**
```bash
pnpm lint          # Check for issues
pnpm lint:fix      # Auto-fix issues
```

**Email development:**
```bash
pnpm email-dev
```
Runs email preview server on port 3030 for React Email components.

**Bundle analysis:**
```bash
ANALYZE_BUNDLE=true pnpm build
```

## Architecture

### Route Structure

The application uses Next.js App Router with two distinct routing groups:

**`src/app/(website)/`** - Public-facing website
- Main website routes (home, blog, events, etc.)
- Custom layout with Navbar, Footer, and ThemeProvider
- German locale (`lang="de"`)
- Includes Umami analytics integration

**`src/app/(payload)/`** - Payload CMS admin panel
- Admin interface at `/admin`
- API routes at `/api`
- Separate layout with Payload's RootLayout
- Auto-generated by Payload (do not manually edit layout)

### Payload CMS Structure

**Collections** (`src/collections/`):
Core data models managed through Payload CMS:
- `Users` - Admin users with Authentik OAuth integration
- `Media`, `TeamBilder` - Media management (stored in S3/Cloudflare R2)
- `Team` - Team member profiles
- `Jahresplan` - Annual calendar/schedule
- `blogPosts`, `blogCategory` - Blog functionality
- `Songs` - Song lyrics and content
- `knallbonbonRegistration`, `knallbonbonEvents` - Knallbonbon event system
- `membershipApplication` - Membership application forms
- `sommerfreizeitUser`, `sommerfreizeitAnmeldung`, `sommerfreizeitFeedback` - Summer camp system with separate auth

**Globals** (`src/globals/`):
Singleton content types (one instance each):
- `Header`, `Footer` - Navigation and footer content
- `Startseite` - Homepage content
- `Rechtliches` - Legal pages
- Event-specific: `Sommerfreizeit`, `Adventsmarkt`, `Martinsumzug`, `Tannenbaumaktion`, `Knallbonbon`
- `aktion72Stunden` - 72-hour action event

**Blocks** (`src/blocks/`):
Reusable content blocks for Lexical editor:
- `FormBlock` - Embedded forms (via form-builder plugin)
- `Code` - Code snippets with syntax highlighting
- `Gallery` - Image galleries
- `cover`, `image`, `videoPlayer` - Media blocks
- `lyrics` - Song lyrics display

Blocks are registered in `payload.config.ts` under `BlocksFeature()` and rendered via custom converters in `src/components/utils/RichText/index.tsx`.

### Authentication

**Two separate auth systems:**

1. **Admin Users** (`Users` collection):
   - OAuth2 via Authentik (configured in `src/utilities/authentikOAuth.ts`)
   - Requires Authentik environment variables (see below)
   - Used for CMS admin access

2. **Sommerfreizeit Users** (`sommerfreizeitUser` collection):
   - Separate auth system for summer camp participants
   - Auth-enabled collection with email/password
   - Routes under `/sommerfreizeit/(auth)/` use this auth
   - Account management at `/sommerfreizeit/account`

### Rich Text Rendering

The project uses Lexical editor with custom block rendering. When working with rich text:
- Configuration: `src/payload.config.ts` (lexicalEditor features)
- Frontend rendering: `src/components/utils/RichText/index.tsx`
- Custom JSX converters map Payload blocks to React components

### Styling

- **Tailwind CSS 4.x** with PostCSS
- Custom styles in `src/styles/globals.css`
- Payload admin customization: `src/styles/payloadStyles.css`
- Theme system via `next-themes` (light/dark mode support)
- Custom font: Caveat (Google Fonts) via CSS variables

### File Storage

Media files use S3-compatible storage (Cloudflare R2):
- `media` collection: General uploads
- `teambilder` collection: Team photos with `teambilder` prefix
- Configuration in `payload.config.ts` under `s3Storage` plugin

## Important Patterns

### Path Aliases

TypeScript path aliases configured in `tsconfig.json`:
- `@/*` → `src/*`
- `@payload-config` → `src/payload.config.ts`

Always use these aliases for imports.

### Environment Variables

Required variables (must be configured):
- `DATABASE_URI` - MongoDB connection string
- `PAYLOAD_SECRET` - Payload CMS encryption secret
- `NEXT_PUBLIC_SITE_URL` - Full site URL
- `NEXT_PUBLIC_SITE_NAME` - Site name (e.g., "KjG Dossenheim")
- `NEXT_PUBLIC_DEFAULT_TIMEZONE` - Default timezone (e.g., "Europe/Berlin")
- `S3_BUCKET_NAME`, `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`, `CLOUDFLARE_ACCOUNT_ID` - S3 storage
- `SMTP_HOST`, `SMTP_USER`, `SMTP_PASS` - Email (Nodemailer)

Optional (for OAuth):
- `AUTHENTIK_CLIENT_ID`, `AUTHENTIK_CLIENT_SECRET`
- `AUTHENTIK_TOKEN_ENDPOINT`, `AUTHENTIK_AUTHORIZATION_URL`, `AUTHENTIK_USERINFO_ENDPOINT`

### Type Safety

After modifying collections or globals, always regenerate types:
```bash
pnpm generate:types
```

This updates `src/payload-types.ts` which is imported throughout the app.

### Working with Collections

When adding/modifying collections:
1. Create/update the collection file in `src/collections/`
2. Import and register in `src/payload.config.ts` (collections array)
3. Run `pnpm generate:types`
4. If used in rich text, add converter in `src/components/utils/RichText/index.tsx`

### Working with Globals

Similar to collections:
1. Create/update in `src/globals/`
2. Import and register in `src/payload.config.ts` (globals array)
3. Run `pnpm generate:types`
4. Fetch via `payload.findGlobal({ slug: 'global-slug' })`

### Custom Admin Views

Custom admin panel views are defined in `payload.config.ts` under `admin.components.views`:
- `knallbonbon` (`/knallbonbon`) - Knallbonbon management view
- `settings` (`/settings`) - Custom settings view
- `emailPreview` (`/email-preview`) - Email template preview

Components located in `src/components/admin/views/`.

### Node Version

Requires Node.js `^18.20.2 || >=20.9.0` (specified in package.json engines).

### Server Actions

The application uses Next.js Server Actions instead of API routes where possible:
- Server actions are located in `actions.ts` files alongside their respective pages
- Example: `/knallbonbon/bestatigen/[registrationId]/actions.ts` for confirmation logic
- Server actions provide better type safety and performance than traditional API routes
- Use the `'use server'` directive at the top of server action files

### Payload Jobs System

Background jobs are handled using Payload's native jobs queue (`src/jobs/`):
- Jobs are stored in the `payload-jobs` MongoDB collection
- Register jobs in `payload.config.ts` under the `jobs.tasks` array
- Jobs can be scheduled with `payload.jobs.queue({ task: 'taskSlug', waitUntil: date })`
- See `src/jobs/README.md` for detailed documentation on creating and scheduling jobs

Example job pattern:
```typescript
export const myJob = {
  slug: 'myJob',
  interfaceName: 'MyJob',
  handler: async ({ req }: any) => {
    // Job logic here
  },
  inputSchema: [],
  retries: 3,
} as const
```

### Collection Hooks Pattern

Collections can have hooks in `src/collections/[collectionName]/hooks/`:
- `afterChange` - Runs after a document is created/updated
- `beforeChange` - Runs before a document is created/updated
- `beforeDelete` - Runs before a document is deleted

Example: `knallbonbonRegistration` collection has hooks for:
- `updateEventParticipantCount` - Updates event capacity when registrations change
- `promoteFromWaitlist` - Automatically promotes waitlisted users when spots open
- `cleanupExpiredConfirmations` - Helper for the cleanup job

### Knallbonbon Event System

Complex waitlist and confirmation workflow:
- Registrations can be waitlisted when events are full
- Automatic promotion system sends confirmation emails with time-limited links
- Confirmation tokens are SHA-256 hashed with `PAYLOAD_SECRET` for security
- Expired confirmations are cleaned up via the `cleanupExpiredConfirmations` job
- Admin views provide custom UI for managing registrations (`/knallbonbon` admin route)

## Common Gotchas

1. **Generated Files**: `src/app/(payload)/layout.tsx` is auto-generated by Payload. Do not modify it directly.

2. **Type Generation**: After schema changes, types won't update until you run `pnpm generate:types`.

3. **Auth Context**: Be aware of which auth system you're working with:
   - Admin routes: `Users` collection
   - `/sommerfreizeit/(auth)/*`: `sommerfreizeitUser` collection

4. **Deprecation Warnings**: All npm scripts use `NODE_OPTIONS=--no-deprecation` to suppress Node.js warnings during development.

5. **Bundle Size**: Next.js bundle analyzer is available via `ANALYZE_BUNDLE=true pnpm build`.

6. **Email Templates**: Email components are in `src/components/email/` and use `@react-email`. Preview with `pnpm email-dev`.

7. **Lexical Blocks**: When adding new blocks to the editor, register them in BOTH:
   - `payload.config.ts` (BlocksFeature)
   - `src/components/utils/RichText/index.tsx` (jsxConverters)

8. **Server Actions vs API Routes**: Prefer server actions over API routes for new features. Server actions provide better type safety, performance, and integrate seamlessly with React Server Components.

9. **Job Scheduling**: Jobs must be manually queued with a `waitUntil` parameter. For recurring jobs, use external cron services (Vercel Cron, GitHub Actions) to trigger re-queuing.
